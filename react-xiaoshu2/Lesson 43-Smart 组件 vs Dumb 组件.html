<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="baidu-site-verification" content="GNvdsbNFPS" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    
      <title>Smart 组件 vs Dumb 组件 | React.js 小书</title>
      <meta name="keywords" content="react.js,web,props,state,javascript" />
      <meta name="description" content="React.js 小书是一个开源、免费、专业、简单的 React.js 在线教程。提炼实战经验中基础的、重要的、频繁的知识进行重点讲解，让你能用最少的精力深入了解实战中最需要的 React.js 知识。" />
    

    

    <link rel="icon" href="https://huzidaha.github.io/static/assets/img/favicon.ico">
    <link rel="stylesheet"
href="https://fonts.googleapis.com/css?family=Inconsolata:400,700">
    <link rel="stylesheet" type="text/css" href="/books/react/assets/css/main.css">
</head>

<body>

    <div class='float-wechat' id='float-wechat'>
    	<img src='https://huzidaha.github.io/static/assets/img/wechat-user.jpeg' />
      <p>加入《React.js 小书》读者交流群，一起讨论、交流、学习前端技术。</p>
    </div>
    <div class="wrapper" id='wrapper'>
      <style media="screen">
@media (max-width: 1335px) and (min-width: 900px) {
	.wrapper {
		margin-left: 329px;
	}
}
@media (max-width: 900px) {
	#table-of-content {
		margin-left: -350px;
	}
}
</style>
<h1 style='position: relative; top: -15px;'>React.js 小书</h1>

<link ref='prefetch' href="/books/react/lesson44" />


<nav class='table-of-content' id='table-of-content'>
	<a href='/books/react'>&lt;-- 首页</a>
	<h3>第一阶段</h3>
  
  
		<a  href="/books/react/lesson1" title="React.js 简介">1. React.js 简介</a>
  
  
  
		<a  href="/books/react/lesson2" title="前端组件化（一）：从一个简单的例子讲起">2. 前端组件化（一）：从一个简单的例子讲起</a>
  
  
  
		<a  href="/books/react/lesson3" title="前端组件化（二）：优化 DOM 操作">3. 前端组件化（二）：优化 DOM 操作</a>
  
  
  
		<a  href="/books/react/lesson4" title="前端组件化（三）：抽象出公共组件类">4. 前端组件化（三）：抽象出公共组件类</a>
  
  
  
		<a  href="/books/react/lesson5" title="React.js 基本环境安装">5. React.js 基本环境安装</a>
  
  
  
		<a  href="/books/react/lesson6" title="使用 JSX 描述 UI 信息">6. 使用 JSX 描述 UI 信息</a>
  
  
  
		<a  href="/books/re,act/lesson7" title="组件的 render 方法">7. 组件的 render 方法</a>
  
  
  
		<a  href="/books/react/lesson8" title="组件的组合、嵌套和组件树">8. 组件的组合、嵌套和组件树</a>
  
  
  
		<a  href="/books/react/lesson9" title="事件监听">9. 事件监听</a>
  
  
  
		<a  href="/books/react/lesson10" title="组件的 state 和 setState">10. 组件的 state 和 setState</a>
  
  
  
		<a  href="/books/react/lesson11" title="配置组件的 props">11. 配置组件的 props</a>
  
  
  
		<a  href="/books/react/lesson12" title="state vs props">12. state vs props</a>
  
  
  
		<a  href="/books/react/lesson13" title="渲染列表数据">13. 渲染列表数据</a>
  
  
  
		<a  href="/books/react/lesson14" title="实战分析：评论功能（一）">14. 实战分析：评论功能（一）</a>
  
  
  
		<a  href="/books/react/lesson15" title="实战分析：评论功能（二）">15. 实战分析：评论功能（二）</a>
  
  
  
		<a  href="/books/react/lesson16" title="实战分析：评论功能（三）">16. 实战分析：评论功能（三）</a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
	<h3>第二阶段</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
		<a  href="/books/react/lesson17" title="前端应用状态管理 —— 状态提升">17. 前端应用状态管理 —— 状态提升</a>
  
  
  
		<a  href="/books/react/lesson18" title="挂载阶段的组件生命周期（一）">18. 挂载阶段的组件生命周期（一）</a>
  
  
  
		<a  href="/books/react/lesson19" title="挂载阶段的组件生命周期（二）">19. 挂载阶段的组件生命周期（二）</a>
  
  
  
		<a  href="/books/react/lesson20" title="更新阶段的组件生命周期">20. 更新阶段的组件生命周期</a>
  
  
  
		<a  href="/books/react/lesson21" title="ref 和 React.js 中的 DOM 操作">21. ref 和 React.js 中的 DOM 操作</a>
  
  
  
		<a  href="/books/react/lesson22" title="props.children 和容器类组件">22. props.children 和容器类组件</a>
  
  
  
		<a  href="/books/react/lesson23" title="dangerouslySetHTML 和 style 属性">23. dangerouslySetHTML 和 style 属性</a>
  
  
  
		<a  href="/books/react/lesson24" title="PropTypes 和组件参数验证">24. PropTypes 和组件参数验证</a>
  
  
  
		<a  href="/books/react/lesson25" title="实战分析：评论功能（四）">25. 实战分析：评论功能（四）</a>
  
  
  
		<a  href="/books/react/lesson26" title="实战分析：评论功能（五）">26. 实战分析：评论功能（五）</a>
  
  
  
		<a  href="/books/react/lesson27," title="实战分析：评论功能（六）">27. 实战分析：评论功能（六）</a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
	<h3>第三阶段</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
		<a  href="/books/react/lesson28" title="高阶组件（Higher-Order Components）">28. 高阶组件（Higher-Order Components）</a>
  
  
  
		<a  href="/books/react/lesson29" title="React.js 的 context">29. React.js 的 context</a>
  
  
  
		<a  href="/books/react/lesson30" title="动手实现 Redux（一）：优雅地修改共享状态">30. 动手实现 Redux（一）：优雅地修改共享状态</a>
  
  
  
		<a  href="/books/react/lesson31" title="动手实现 Redux（二）：抽离 store 和监控数据变化">31. 动手实现 Redux（二）：抽离 store 和监控数据变化</a>
  
  
  
		<a  href="/books/react/lesson32" title="动手实现 Redux（三）：纯函数（Pure Function）简介">32. 动手实现 Redux（三）：纯函数（Pure Function）简介</a>
  
  
  
		<a  href="/books/react/lesson33" title="动手实现 Redux（四）：共享结构的对象提高性能">33. 动手实现 Redux（四）：共享结构的对象提高性能</a>
  
  
  
		<a  href="/books/react/lesson34" title="动手实现 Redux（五）：不要问为什么的 reducer">34. 动手实现 Redux（五）：不要问为什么的 reducer</a>
  
  
  
		<a  href="/books/react/lesson35" title="动手实现 Redux（六）：Redux 总结">35. 动手实现 Redux（六）：Redux 总结</a>
  
  
  
		<a  href="/books/react/lesson36" title="动手实现 React-redux（一）：初始化工程">36. 动手实现 React-redux（一）：初始化工程</a>
  
  
  
		<a  href="/books/react/lesson37" title="动手实现 React-redux（二）：结合 context 和 store">37. 动手实现 React-redux（二）：结合 context 和 store</a>
  
  
  
		<a  href="/books/react/lesson38" title="动手实现 React-redux（三）：connect 和 mapStateToProps">38. 动手实现 React-redux（三）：connect 和 mapStateToProps</a>
  
  
  
		<a  href="/books/react/lesson39" title="动手实现 React-redux（四）：mapDispatchToProps">39. 动手实现 React-redux（四）：mapDispatchToProps</a>
  
  
  
		<a  href="/books/react/lesson40" title="动手实现 React-redux（五）：Provider">40. 动手实现 React-redux（五）：Provider</a>
  
  
  
		<a  href="/books/react/lesson41" title="动手实现 React-redux（六）：React-redux 总结">41. 动手实现 React-redux（六）：React-redux 总结</a>
  
  
  
		<a  href="/books/react/lesson42" title="使用真正的 Redux 和 React-redux">42. 使用真正的 Redux 和 React-redux</a>
  
  
  
		<a  class='active'  href="/books/react/lesson43" title="Smart 组件 vs Dumb 组件">43. Smart 组件 vs Dumb 组件</a>
  
  
  
		<a  href="/books/react/lesson44" title="实战分析：评论功能（七）">44. 实战分析：评论功能（七）</a>
  
  
  
		<a  href="/books/react/lesson45" title="实战分析：评论功能（八）">45. 实战分析：评论功能（八）</a>
  
  
  
		<a  href="/books/react/lesson46" title="实战分析：评论功能（九）">46. 实战分析：评论功能（九）</a>
  
  
</nav>
<div id="mask-template">
	<div></div>
</div>
<style>
	#granted-modal {
		display: none;
		position: fixed;
		margin: auto;
		left: 100px;
		top: 0;
		bottom: 100px;
		right: 0;
		width: 500px;
		height: 300px;
		background: #fff;
		z-index: 100;
		border-radius: 5px;
	}
	#try-to-buy {
		display: none;
	}
	.error-message {
    position: absolute;
    bottom: 7px;
    right: -30px;
    font-size: 12px;
    color: rgb(211, 53, 62);
  }
	.field {
		position: relative;
		margin-top: 25px;
	}
	.modal-head {
		font-size: 20px;
    text-align: center;
    margin-top: 30px;
	}
	.granted-footer {
		text-align: center;
	}
	#back-to-input {
		font-size: 12px;
    position: absolute;
    top: 10px;
    left: 15px;
	}
	.hover {
		cursor: pointer;
	}
	.granted-footer {
		position: absolute;
    margin: auto;
		padding-top: 15px;
    left: 30px;
    right: 30px;
    bottom: 20px;
		border-top: 1px solid #eee;
	}
	#buy-now {
		color: #00a854;
	}
	.field label {
		display: inline-block;
		width: 90px;
		text-align: right;
	}
	.field label::after {
		content: "："
	}
	.granted-form {
		width: 80%;
		margin: 0 auto;
		margin-top: 25px;
	}
	.submit {
		display: inline-block;
		float: right;
	}
	.button {
		background: #f7f7f7;
		border: 1px solid #ccc;
		padding: 5px 20px;
		border-radius: 3px;
		outline: none;
	}
	.button:hover {
		background: #fff;
	}
	.field input {
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #e0dbdb;
    width: 166px;
	}
</style>
<div id="granted-modal">
	<div style="padding: 10px;">
		<div id="readcode-input-area">
			<h2 class="modal-head">阅读第三阶段，请输入你的阅读码 </h2>
			<form class="granted-form" id="read-code-form">
				<div class="field">
					<label>Email</label>
					<input type="email" id="email">
				</div>
				<div class="field">
					<label>阅读码</label>
					<input type="text" id="read-code">
				</div>
				<button id="check-granted" class="button hover submit">确认</button>
			</form>
			<div class="granted-footer">
				还没有阅读码？<b>¥10</b> 元即可阅读所有章节
				<p style="margin-top: 10px;"><a class="hover" id="buy-now">马上获取阅读码</a></p>
			</div>
		</div>
		<div id="try-to-buy">
			<div id="back-to-input" class="hover">&lt;&lt; 返回</div>
			<h2 class="modal-head">输入你的邮箱，系统会给你发送邮件</h2>
			<form class="granted-form" id="get-read-code-form">
				<div class="field">
					<label>Email</label>
					<input type="email" id="reader-email">
				</div>
				<button id="alipay" style="margin-top: 20px;" class="hover submit button">获取阅读码</button>
			</form>
		</div>
	</div>
</div>
<script src="/books/react/assets/js/jquery-3.2.1.min.js"></script>
<script src="/books/react/assets/js/pay.min.js"></script>
<script type="text/javascript">
var tableOfContent = document.getElementById('table-of-content')
var timer = null
function resetTableOfContent (rect) {
  scrollTop = localStorage.getItem('scrollTop') * 1
  scrollTop = scrollTop || 0
  tableOfContent.scrollTop = scrollTop
}
tableOfContent.addEventListener('scroll', function (event) {
  clearTimeout(timer)
  timer = setTimeout(function() {
    localStorage.setItem('scrollTop', tableOfContent.scrollTop)
  }, 50)
}, false)
resetTableOfContent()
</script>
<div class="post">
	<div class="post__back">
  	<a href="/books/react">&lt;-- 返回首页</a>
    <div class="post__title">
    	<h1>Smart 组件 vs Dumb 组件</h1>
    </div>
    <div class="post__meta">
    	<p></p>
    </div>
    <div class="post__content"?>
      <ul style="font-size: 14px; margin-top: -10px;">
  <li>
    作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha" target="_blank">胡子大哈</a>
  </li>
  <li>
    原文链接：<a href="http://huziketang.com/books/react/lesson43"> http://huziketang.com/books/react/lesson43 </a>
  </li>
  <li>转载请注明出处，保留原文链接和作者信息。</li>
</ul>

<p>（本文未审核）</p>

<p>大家已经知道，只会接受 <code>props</code> 并且渲染确定结果的组件我们把它叫做 Dumb 组件，这种组件只关心一件事情 —— 根据 <code>props</code> 进行渲染。</p>

<p>Dumb 组件最好不要依赖除了 React.js 和 Dumb 组件以外的内容。它们不要依赖 Redux 不要依赖 React-redux。这样的组件的可复用性是最好的，其他人可以安心地使用而不用怕会引入什么奇奇怪怪的东西。</p>

<p>当我们拿到一个需求开始划分组件的时候，要认真考虑每个被划分成组件的单元到底会不会被复用。如果这个组件可能会在多处被使用到，那么我们就把它做成 Dumb 组件。</p>

<p>我们可能拆分了一堆 Dumb 组件出来。但是单纯靠 Dumb 是没有办法构建应用程序的，因为它们实在太“笨”了，对数据的力量一无所知。所以还有一种组件，它们非常聪明（smart），城府很深精通算计，我们叫它们 Smart 组件。它们专�,��做数据相关的应用逻辑，和各种数据打交道、和 Ajax 打交道，然后把数据通过 <code>props</code> 传递给 Dumb，它们带领着 Dumb 组件完成了复杂的应用程序逻辑。</p>

<p><a href="http://huzidaha.github.io/static/assets/img/posts/25608378-BE07-4050-88B1-72025085875A.png" target="_blank"><img src="http://huzidaha.github.io/static/assets/img/posts/25608378-BE07-4050-88B1-72025085875A.png" alt="实例图片" /></a></p>

<p>Smart 组件不用考虑太多复用性问题，它们就是用来执行特定应用逻辑的。Smart 组件可能组合了 Smart 组件和 Dumb 组件；但是 Dumb 组件尽量不要依赖 Smart 组件。因为 Dumb 组件目的之一是为了复用，一旦它引用了 Smart 组件就相当于带入了一堆应用逻辑，导致它无法无用，所以尽量不要干这种事情。一旦一个可复用的 Dumb 组件之下引用了一个 Smart 组件，就相当于污染了这个 Dumb 组件树。如果一个组件是 Dumb 的，那么它的子组件们都应该是 Dumb 的才对。</p>

<h2 id="划分-smart-和-dumb--组件">划分 Smart 和 Dumb  组件</h2>
<p>知道了组件有这两种分类以后，我们来重新审视一下之前的 <code>make-react-redux</code> 工程里面的组件，例如 <code>src/Header.js</code>：</p>

<pre><code class="language-javascript">import React, { Component, PropTypes } fro,m 'react'
import { connect } from 'react-redux'

class Header extends Component {
  static propTypes = {
    themeColor: PropTypes.string
  }

  render () {
    return (
      &lt;h1 style={{ color: this.props.themeColor }}&gt;React.js 小书&lt;/h1&gt;
    )
  }
}

const mapStateToProps = (state) =&gt; {
  return {
    themeColor: state.themeColor
  }
}
Header = connect(mapStateToProps)(Header)

export default Header
</code></pre>

<p>这个组件到底是 Smart 还是 Dumb 组件？这个文件其实依赖了 <code>react-redux</code>，别人使用的时候其实会带上这个依赖，所以这个组件不能叫 Dumb 组件。但是你观察一下，这个组件在 <code>connect</code> 之前它却是 Dumb 的，就是因为 <code>connect</code> 了导致它和 context 扯上了关系，导致它变 Smart 了，也使得这个组件没有了很好的复用性。</p>

<p>为了解决这个问题，我们把 Smart 和 Dumb 组件分开到两个不同的目录，不再在 Dumb 组件内部进行 <code>connect</code>，在 <code>src/</code> 目录下新建两个文件夹 <code>components/</code> 和 <code>containers/</code>：</p>

<pre><code>src/
  components/
  containers/
</code></pre>

<p>我们规定：<em>所有的 Dumb 组件都放在 <code>components/</code> 目录下，所有的 Smart 的组件都放在 <code>containers/</code> 目录下</em>，这是一种约定俗成�,��规则。</p>

<p>删除 <code>src/Header.js</code>，新增 <code>src/components/Header.js</code>：</p>

<pre><code class="language-javascript">import React, { Component, PropTypes } from 'react'

export default class Header extends Component {
  static propTypes = {
    themeColor: PropTypes.string
  }

  render () {
    return (
      &lt;h1 style={{ color: this.props.themeColor }}&gt;React.js 小书&lt;/h1&gt;
    )
  }
}
</code></pre>

<p>现在 <code>src/components/Header.js</code> 毫无疑问是一个 Dumb 组件，它除了依赖 React.js 什么都不依赖。我们新建 <code>src/container/Header.js</code>，这是一个与之对应的 Smart 组件：</p>

<pre><code class="language-javascript">import { connect } from 'react-redux'
import Header from '../components/Header'

const mapStateToProps = (state) =&gt; {
  return {
    themeColor: state.themeColor
  }
}
export default connect(mapStateToProps)(Header)
</code></pre>

<p>它会从导入 Dumb 的 <code>Header.js</code> 组件，进行 <code>connect</code> 一番变成 Smart 组件，然后把它导出模块。</p>

<p>这样我们就把 Dumb 组件抽离出来了，现在 <code>src/components/Header.js</code> 可复用性非常强，别的同事可以随意用它。而 <code>src/containers/Header.js</code> 则是跟业务相关的，我们只用在特定的应用场景下。我们可以继续用这种方式�,�重构其他组件。</p>

<h2 id="组件划分原则">组件划分原则</h2>
<p>接下来的情况就有点意思了，可以趁机给大家讲解一下组件划分的一些原则。我们看看这个应用原来的组件树：</p>

<p><a href="http://huzidaha.github.io/static/assets/img/posts/9271BF94-6599-4F73-A814-0DDA20B634D9.png" target="_blank"><img src="http://huzidaha.github.io/static/assets/img/posts/9271BF94-6599-4F73-A814-0DDA20B634D9.png" alt="实例图片" /></a></p>

<p>对于 <code>Content</code> 这个组件，可以看到它是依赖 <code>ThemeSwitch</code> 组件的，这就需要好好思考一下了。我们分两种情况来讨论：<code>Content</code> <em>不复用</em>和<em>可复用</em>。</p>

<h3 id="content-不复用">Content 不复用</h3>

<p>如果产品场景并没有要求说 <code>Content</code> 需要复用，它只是在特定业务需要而已。那么没有必要把 <code>Content</code> 做成 Dumb 组件了，就让它成为一个 Smart 组件。因为 Smart 组件是可以使用 Smart 组件的，所以 <code>Content</code> 可以使用 Dumb 的 <code>ThemeSwitch</code> 组件 <code>connect</code> 的结果。</p>

<p>新建一个 <code>src/components/ThemeSwitch.js</code>：</p>

<pre><code class="language-javascript">import React, { Component, PropTypes } from 'react'

export default class ThemeSwitch extends Component {
  static propTypes = {
    themeColor: PropTypes.string,
    onSwitchColor: PropTypes.func
  }

  handleSwitchColor (color) {
    if (this.props.onSwitchColor) {
      this.props.onSwitchColor(color)
    }
  }

  render () {
    return (
      &lt;div&gt;
        &lt;button
          style={{ color: this.props.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'red')}&gt;Red&lt;/button&gt;
        &lt;button
          style={{ color: this.props.themeColor }}
          onClick={this.handleSwitchColor.bind(this, 'blue')}&gt;Blue&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>这是一个 Dumb 的 <code>ThemeSwitch</code>。新建一个 <code>src/containers/ThemeSwitch.js</code>：</p>

<pre><code class="language-javascript">import { connect } from 'react-redux'
import ThemeSwitch from '../components/ThemeSwitch'

const mapStateToProps = (state) =&gt; {
  return {
    themeColor: state.themeColor
  }
}
const mapDispatchToProps = (dispatch) =&gt; {
  return {
    onSwitchColor: (color) =&gt; {
      dispatch({ type: 'CHANGE_COLOR', themeColor: color })
    }
  }
}
export default connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)
</code></pre>

<p>这是一个 Smart 的 <code>ThemeSwitch</code>。然后用一个 Smart 的 <code>Content</code> 去使用它，新建 <code>src/containers/Content.js</code>：</p>

<pre><code class="language-javascript">import React, { Component, PropTypes } from 'react'
import ThemeSwitch from './ThemeSwitch'
import { connect } from 'react-redux'

class Content extends Component {
  static propTypes = {
    themeColor: PropTypes.string
  }

  render () {
    return (
      &lt;div&gt;
        &lt;p style={{ color: this.props.themeColor }}&gt;React.js 小书内容&lt;/p&gt;
        &lt;ThemeSwitch /&gt;
      &lt;/div&gt;
    )
  }
}

const mapStateToProps = (state) =&gt; {
  return {
    themeColor: state.themeColor
  }
}
export default connect(mapStateToProps)(Content)
</code></pre>

<p>删除 <code>src/ThemeSwitch.js</code> 和 <code>src/Content.js</code>，在 <code>src/index.js</code> 中直接使用 Smart 组件：</p>

<pre><code class="language-javascript">...
import Header from './containers/Header'
import Content from './containers/Content'
...
</code></pre>

<p>这样就把这种业务场景下的 Smart 和 Dumb 组件分离开来了：</p>

<pre><code>src
├── components
│   ├── Header.js
│   └── ThemeSwitch.js
├── containers
│   ├── Content.js
│   ├── Header.js
│   └── ThemeSwitch.js
└── index.js
</code></pre>

<h3 id="content-可复用">Content 可复用</h3>

<p>如果产品场景要求 <code>Content</code> 可能会被复用，那么 <code>Content</code> 就要是 Dumb 的。那么 <code>Content</code> 的之下的,子组件 <code>ThemeSwitch</code> 就一定要是 Dumb，否则 <code>Content</code> 就没法复用了。这就意味着 <code>ThemeSwitch</code> 不能 <code>connect</code>，即使你 <code>connect</code> 了，<code>Content</code> 也不能使用你 <code>connect</code> 的结果，因为 <code>connect</code> 的结果是个 Smart 组件。</p>

<p>这时候 <code>ThemeSwitch</code> 的数据、<code>onSwitchColor</code> 函数只能通过它的父组件传进来，而不是通过 <code>connect</code> 获得。所以只能让 <code>Content</code> 组件去 <code>connect</code>，然后让它把数据、函数传给 <code>ThemeSwitch</code>。</p>

<p>这种场景下的改造留给大家做练习，最后的结果应该是：</p>

<pre><code>src
├── components
│   ├── Header.js
│   ├── Content.js
│   └── ThemeSwitch.js
├── containers
│   ├── Header.js
│   └── Content.js
└── index.js
</code></pre>

<p>可以看到对复用性的需求不同，会导致我们划分组件的方式不同。</p>

<h2 id="总结">总结</h2>
<p>根据是否需要高度的复用性，把组件划分为 Dumb 和 Smart 组件，约定俗成地把它们分别放到 <code>components</code> 和 <code>containers</code> 目录下。</p>

<p>Dumb 基本只做一件事情 —— 根据 <code>props</code> 进行渲染。而 Smart 则是负�,��应用的逻辑、数据，把所有相关的 Dumb（Smart）组件组合起来，通过 <code>props</code> 控制它们。</p>

<p>Smart 组件可以使用 Smart、Dumb 组件；而 Dumb 组件最好只使用 Dumb 组件，否则它的复用性就会丧失。</p>

<p>要根据应用场景不同划分组件，如果一个组件并不需要太强的复用性，直接让它成为 Smart 即可；否则就让它成为 Dumb 组件。</p>

<p>还有一点要注意，Smart 组件并不意味着完全不能复用，Smart 组件的复用性是依赖场景的，在特定的应用场景下是当然是可以复用 Smart 的。而 Dumb 则是可以跨应用场景复用，Smart 和 Dumb 都可以复用，只是程度、场景不一样。</p>

<hr />

<blockquote>
  <p>因为第三方评论工具有问题，对本章节有任何疑问的朋友可以移步到 <a target="_blank" href="http://scriptoj.com/category/4/react-js-小书交流区">React.js 小书的论坛</a> 发帖，我会回答大家的疑问。</p>
</blockquote>

    </div>
		<br/>
		<hr />
		<br />
		<div class="PageNavigation">
			
			<p>
				<a class="next" href="/books/react/lesson44">下一节：实战分析：评论功能（七）</a>
			</p>
			
			<br/>
			
			<p>
				<a class="prev" href="/books/react/lesson42">上一节：使用真正的 Redux 和 React-redux</a>
			</p>
			
		</div>
		<!-- <a class="ad" href="https://aonaotu.com" target="_blank"> -->
			<!-- <div class="ad-logo">
				<img src="/books/react/assets/img/ad-logo.svg">
				<p class="ad-title">凹脑图</p>
			</div>
			<p class="ad-wording">迄今为止最简单好用的在线思维导图工具</p>
			<span class="ad-indicator">广告</span>
			<img src="/books/react/assets/img/ad-bg-2.svg" class="ad-bg-2">
		</a> -->
		<!-- <div class='share-block margin-top-gap'>
			<p>如果你觉得小书写得还不错，可以请胡子大哈喝杯茶 :)</p>
			<button class='donate-button' id='donate-button' type="button">赞赏</button>
		</div> -->
		<div class='share-block margin-bottom-gap'>
			<p>传播一下知识也是一个很好的选择</p>
			<div class="share-block-inner">
				<div class="jiathis_style_24x24">
					<a class="jiathis_button_qzone"></a>
					<a class="jiathis_button_tsina"></a>
					<a class="jiathis_button_tqq"></a>
					<a class="jiathis_button_weixin"></a>
					<a class="jiathis_button_renren"></a>
					<a href="http://www.jiathis.com/share?uid=2127727" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
				</div>
				<script type="text/javascript">
				var jiathis_config = {data_track_clickback:'true'};
				</script>
				<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2127727" charset="utf-8"></script>
			</div>
		</div>
		<!-- UY BEGIN -->
		<div id="uyan_frame"></,div>
		<script type="text/javascript">
		var paths = window.location.pathname.split('/')
		var lessonName = paths[paths.length - 1]
		var uyan_config = {
			// 'url': 'http://react.huziketang.com/blog/' + lessonName,
			'du': 'react.huziketang.com'
		}
		</script>
		<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2127727"></script>
		<!-- UY END -->
		<!--wechat donate-->
		<div class='donate-mask' id='donate-mask'>
			<img src='https://huzidaha.github.io/static/assets/img/wechat-pay.png' id='wechat-pay' />
		</div>
		<script type="text/javascript">
			// var donateMask = document.getElementById('donate-mask')
			// var donateButton = document.getElementById('donate-button')
			// var wechatPay = document.getElementById('wechat-pay')
			// donateButton.addEventListener('click', function () {
			// 	donateMask.style.display = 'flex'
			// }, false)
			// donateMask.addEventListener('click', function () {
			// 	donateMask.style.display = 'none'
			// }, false)
			// wechatPay.addEventListener('click', function (event) {
			// 	event.stopPropagation()
			// }, false)
		</script>
	</div>

    </div>
    <script src="/books/react/assets/js/highlight.js"></script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      if (window.location.origin.match(/localhost/)) return
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f08b5240ef2d1692572ce0f7756b325e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
      var bp = document.createElement('script');
      // push baidu.com
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
    var wrapper = document.getElementById('wrapper')
    var floatWechat = document.getElementById('float-wechat')

    function resetAll (event) {
      var rect = wrapper.getBoundingClientRect()
      resetFloatWechat(rect)
    }
    function resetFloatWechat(rect) {
      var left = rect.left + rect.width
      floatWechat.style.left = left + 'px'
      floatWechat.style.display = 'block'
    }
    window.addEventListener('resize', resetAll)
    resetAll()
    </script>

</body>

</html>
<link rel="stylesheet" href="http://huziketang.com/books/react/assets/css/main.css">